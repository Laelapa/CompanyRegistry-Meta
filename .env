#This is an example env configuration. It works for running the project trivially - demo-ing
ENVIRONMENT=production #prod|production|stg|staging|dev|development|test|testing
SERVER_PORT=8080
SERVER_SHUTDOWN_TIMEOUT=15s #h|m|s|ms|us|ns - can combine: 2h45m30s
SERVER_READ_HEADER_TIMEOUT=10s #for slow headers
SERVER_READ_TIMEOUT=30s #for slow requests
SERVER_WRITE_TIMEOUT=30s #prevent clients from keeping connections open
SERVER_IDLE_TIMEOUT=120s #keep-alive timeout
JWT_SECRET=dev_jwt_secret_change_in_production_min_32_chars #can gen with: `openssl rand -base64 64`
JWT_ISSUER=company-registry-service
JWT_LIFETIME=15m #can't revoke, use shorter lifetimes
SERVICE_NAME=company-registry-service #for logging & events
KAFKA_BROKERS=localhost:29092
KAFKA_TOPIC_COMPANIES=company.mutations
KAFKA_TOPIC_USERS=user.mutations
LOGGER_SETUP=production #does nothing for now :)
MAX_HEADER_LENGTH=1000000 #1MB

POSTGRES_USER=company_registry_user
POSTGRES_PASSWORD=change_this_password_in_production
POSTGRES_DB=company_registry_db
POSTGRES_PORT=5432

#This only gets used by the locally compiled and run application. The docker-compose one sources the POSTGRES_VARS directly to build it
DB_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@localhost:${POSTGRES_PORT}/${POSTGRES_DB}?sslmode=disable 

GOOSE_DRIVER=postgres
GOOSE_DBSTRING=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@localhost:${POSTGRES_PORT}/${POSTGRES_DB}?sslmode=disable
